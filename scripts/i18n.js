const fs = require('fs');
const path = require('path');
const rimraf = require('rimraf');
const chalk = require('chalk');

const IN_PATH = path.resolve(process.cwd(), 'src', 'i18n', 'sv.json');
const OUT_PATH = path.resolve(process.cwd(), 'src', 'i18n.ts');

module.exports.generate = (langFile) => {
  let document = `// Last synced: ${new Date().toISOString()} by ${require("os").userInfo().username}\n`;
  document += `// This file is automatically generated, do not edit manually!\n\n`;

  fs.readFile(langFile, 'utf8', (err, language) => {
    if (err) throw err;

    const lang = JSON.parse(language);
    const ids = module.exports.reviver('', '', lang);
    document += `export const Lang = ${JSON.stringify(ids, null, 2)}`
    document = module.exports.clean(document);

    fs.writeFileSync(OUT_PATH, document, 'utf8');
  });
}

module.exports.reviver = (parent, key, value) => {
  let temp;
  switch (typeof value) {
    case 'object':
      temp = {};
      for (const k in value) {
        const newKey = module.exports.snakeToPascal(k);
        temp[newKey] = module.exports.reviver(parent ? `${parent}.${key}` : key, k, value[k]);
      }
      break;

    case 'string':
      temp = `${parent}.${key}`;
  }
  return temp;
}

module.exports.snakeToPascal = (s) => {
  return s.replace(/(^\w|\_\w)/g, m => (m[1] || m[0]).toUpperCase());
}

module.exports.clean = (document) => {
  document = document.replace(/\"/g, '\'');
  document = document.replace(/(}|')\n/g, '$1,\n');
  document += ';\n';
  return document;
}

if (require.main === module) {
  module.exports.generate(IN_PATH);
}
